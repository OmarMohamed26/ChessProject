/**
 * hash.c
 *
 * Responsibilities:
 * - Manage a dynamic array of game state hashes (DynamicHashArray).
 * - Compute the hash of the current game state (using FEN and MD5).
 * - Check for threefold repetition by comparing the current hash against history.
 *
 * Implementation Details:
 * - Uses a dynamic array (DHA) that auto-expands when full.
 * - Hashes are 128-bit values (stored as 4 uint32_t) derived from MD5.
 * - The hash computation relies on the FEN string generated by save.c.
 */

#include "hash.h"
#include "raylib.h"
#include "save.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Local prototype
static bool ExpandDHA(DynamicHashArray *DHA, size_t expandFactor);

/**
 * InitializeDHA
 *
 * Allocates and initializes a new DynamicHashArray.
 *
 * Parameters:
 *  - capacity: Initial number of slots to allocate.
 *
 * Returns:
 *  - Pointer to the new DynamicHashArray, or NULL on allocation failure.
 */
DynamicHashArray *InitializeDHA(size_t capacity)
{
    if (capacity < 1)
    {
        capacity = 1;
    }

    DynamicHashArray *DHA = malloc(sizeof(DynamicHashArray));

    if (DHA == NULL)
    {
        TraceLog(LOG_DEBUG, "Failed to create space for DynamicHashArray.");
        return NULL;
    }

    DHA->hashArray = malloc(sizeof(Hash) * capacity);

    if (DHA->hashArray == NULL)
    {
        TraceLog(LOG_DEBUG, "Failed to create space for hashArray.");
        free(DHA);
        return NULL;
    }

    DHA->size = 0;
    DHA->capacity = capacity;

    return DHA;
}

/**
 * FreeDHA
 *
 * Frees all memory associated with a DynamicHashArray.
 */
void FreeDHA(DynamicHashArray *DHA)
{
    if (DHA == NULL)
    {
        return;
    }

    free(DHA->hashArray);
    free(DHA);
}

/**
 * ClearDHA
 *
 * Resets the size of the array to 0 without freeing memory.
 * Effectively clears the history.
 */
void ClearDHA(DynamicHashArray *DHA)
{
    DHA->size = 0;
}

/**
 * PushDHA
 *
 * Adds a new hash to the end of the array.
 * Automatically expands the array if capacity is reached.
 *
 * Returns:
 *  - true if successful, false if expansion failed.
 */
bool PushDHA(DynamicHashArray *DHA, Hash hash)
{
    if (DHA->size >= DHA->capacity)
    {
        if (!ExpandDHA(DHA, 2))
        {
            return false;
        }
    }

    DHA->hashArray[DHA->size++] = hash;
    return true;
}

/**
 * PopDHA
 *
 * Removes and returns the last hash added to the array.
 * Used when undoing moves.
 *
 * Returns:
 *  - The removed Hash, or a zeroed Hash if empty.
 */
Hash PopDHA(DynamicHashArray *DHA)
{
    if (DHA->size == 0)
    {
        return (Hash){0};
    }

    return DHA->hashArray[DHA->size--];
}

/**
 * ExpandDHA (static)
 *
 * Helper to increase the capacity of the dynamic array.
 */
static bool ExpandDHA(DynamicHashArray *DHA, size_t expandFactor)
{
    Hash *temp = realloc(DHA->hashArray, sizeof(Hash) * DHA->capacity * expandFactor);

    if (temp == NULL)
    {
        TraceLog(LOG_DEBUG, "Failed to expand the DHA.");
        return false;
    }

    DHA->hashArray = temp;
    DHA->capacity *= expandFactor;
    TraceLog(LOG_DEBUG, "Expanded the DHA to new capacity:%zu", DHA->capacity);
    return true;
}

/**
 * IsRepeated3times
 *
 * Checks if the provided 'currentHash' appears at least 2 times in the history.
 * (2 times in history + 1 current occurrence = 3 repetitions).
 *
 * Parameters:
 *  - DHA: The history of previous game states.
 *  - currentHash: The hash of the board state right now.
 *
 * Returns:
 *  - true if the position has occurred 3 times total.
 */
bool IsRepeated3times(DynamicHashArray *DHA, Hash currentHash)
{
    int count = 1; // 1 for the current position we are holding

    // Optimization: If history is tiny, it can't be a repetition yet
    if (DHA->size < 2) // Need at least 2 previous occurrences to make 3
    {
        return false;
    }

    for (size_t i = 0; i < DHA->size; i++)
    {
        if (memcmp(&DHA->hashArray[i], &currentHash, sizeof(Hash)) == 0)
        {
            if (++count >= 3)
            {
                return true;
            }
        }
    }

    return false;
}

/**
 * CurrentGameStateHash
 *
 * Generates a unique hash for the current board state.
 *
 * Mechanism:
 * 1. Calls SaveFEN() to get the board string.
 * 2. Truncates the FEN to remove move counters (halfmove/fullmove clocks)
 *    because repetition depends only on piece placement, turn, castling, and en passant.
 * 3. Computes MD5 hash of this string.
 *
 * Returns:
 *  - A Hash struct containing the 128-bit MD5 signature.
 */
Hash CurrentGameStateHash(void)
{
    unsigned char *currentState = SaveFEN();
    int spaceCount = 0;

    // We only care about the first 4 fields of FEN for repetition:
    // 1. Piece placement
    // 2. Active color
    // 3. Castling availability
    // 4. En passant target square
    // The 5th and 6th fields (halfmove clock, fullmove number) are irrelevant for 3-fold repetition.
    int counter;
    for (counter = 0; spaceCount < 4; spaceCount += currentState[counter++] == ' ')
    {
        ;
    }

    currentState[counter - 1] = '\0';

    int dataSize = (int)strlen((const char *)currentState);
    unsigned int *array = ComputeMD5(currentState, dataSize);

    free(currentState);
    Hash hash = {0};

    if (array)
    {
        memcpy(hash.data, array, sizeof(Hash));
    }

    return hash;
}
